name: CI

on: [push, pull_request]

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    env:
      TERM: xterm
      COLUMNS: 80
      LINES: 24

    steps:
      - uses: actions/checkout@v4

      - name: Install build deps (gcc/make/readline/ncurses)
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential libreadline-dev libncurses-dev

      - name: Clean & Build (verbose if supported)
        run: |
          set -euxo pipefail
          if grep -qE '^[[:space:]]*clean:' Makefile; then make clean || true; fi
          ( make VERBOSE=1 ) || make
          echo "---- executables ----"
          find . -maxdepth 3 -type f -perm -111 -print || true
          echo "---------------------"

      - name: Locate binary
        id: bin
        shell: bash
        run: |
          set -e
          CANDIDATES=(./mysh ./bin/mysh ./build/mysh ./out/mysh ./src/mysh)
          BIN=""
          for c in "${CANDIDATES[@]}"; do
            if [[ -x "$c" ]]; then BIN="$c"; break; fi
          done
          if [[ -z "$BIN" ]]; then
            BIN=$(find . -maxdepth 3 -type f -name 'mysh' -perm -111 | head -n1 || true)
          fi
          if [[ -z "$BIN" ]]; then
            echo "Binary 'mysh' not found after build."
            exit 1
          fi
          echo "BIN=$BIN" >> "$GITHUB_OUTPUT"
          echo "Using binary: $BIN"
          file "$BIN" || true
          ldd "$BIN" || true

      # Smoke 1: ensure the shell can start, run a simple command, and exit
      - name: Smoke 1 — start, run 'pwd', exit
        run: |
          set -euo pipefail
          BIN="${{ steps.bin.outputs.BIN }}"
          # Run with a timeout to avoid hangs; accept any output (prompts, colors, etc.)
          timeout 6s bash -lc "printf 'pwd\nexit\n' | \"$BIN\"" > out1.txt 2>&1 || (echo 'Shell run failed'; sed -n '1,120p' out1.txt; exit 1)
          # Be lenient: just assert that SOME non-empty output exists
          test -s out1.txt || (echo '::error::no output produced by shell'; exit 1)

      # Smoke 2: redirection must work (no dependence on built-ins)
      - name: Smoke 2 — redirection 'echo 123 > /tmp/ts_out.txt'
        run: |
          set -euo pipefail
          BIN="${{ steps.bin.outputs.BIN }}"
          rm -f /tmp/ts_out.txt
          timeout 6s bash -lc "printf 'echo 123 > /tmp/ts_out.txt\nexit\n' | \"$BIN\"" > out2.txt 2>&1 || (sed -n '1,120p' out2.txt; exit 1)
          test -f /tmp/ts_out.txt || (echo '::error::redirection did not create file'; sed -n '1,120p' out2.txt; exit 1)
          grep -q '123' /tmp/ts_out.txt || (echo '::error::redirection file did not contain expected text'; sed -n '1,120p' out2.txt; exit 1)

      # Smoke 3: a basic pipeline must work; look for the transformed text anywhere
      - name: Smoke 3 — simple pipe 'echo aa | tr a A'
        run: |
          set -euo pipefail
          BIN="${{ steps.bin.outputs.BIN }}"
          timeout 6s bash -lc "printf 'echo aa | tr a A\nexit\n' | \"$BIN\"" > out3.txt 2>&1 || (sed -n '1,120p' out3.txt; exit 1)
          grep -q 'AA' out3.txt || (echo '::error::pipe output AA not observed'; sed -n '1,120p' out3.txt; exit 1)
