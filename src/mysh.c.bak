# define _GNU_SOURCE
# include <errno.h>
# include <limits.h>
# include <stdbool.h>
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <sys/types.h>
# include <sys/wait.h>
# include <unistd.h>

# include <readline/readline.h>
# include <readline/history.h>

# define MAX_LINE 1024
# define MAX_ARGS 128

/* ---------- Aliases ---------- */
struct Alias { char name[64]; char value[256]; };
static struct Alias ALIASES[32];
static int ALIAS_N = 0;

static const char* alias_lookup(const char* name){
    for (int i = 0; i < ALIAS_N; i++)
        if (!strcmp(ALIASES[i].name, name)) return ALIASES[i].value;
    return NULL;
}
static void alias_set(const char* name, const char* value){
    for (int i = 0; i < ALIAS_N; i++){
        if (!strcmp(ALIASES[i].name, name)) {
            strncpy(ALIASES[i].value, value, sizeof(ALIASES[i].value));
            ALIASES[i].value[sizeof(ALIASES[i].value)-1] = '\0';
            return;
        }
    }
    if (ALIAS_N < (int)(sizeof(ALIASES)/sizeof(ALIASES[0]))) {
        strncpy(ALIASES[ALIAS_N].name, name, sizeof(ALIASES[ALIAS_N].name));
        ALIASES[ALIAS_N].name[sizeof(ALIASES[ALIAS_N].name)-1] = '\0';
        strncpy(ALIASES[ALIAS_N].value, value, sizeof(ALIASES[ALIAS_N].value));
        ALIASES[ALIAS_N].value[sizeof(ALIASES[ALIAS_N].value)-1] = '\0';
        ALIAS_N++;
    }
}
static void alias_unset(const char* name){
    for (int i = 0; i < ALIAS_N; i++){
        if (!strcmp(ALIASES[i].name, name)) {
            ALIASES[i] = ALIASES[--ALIAS_N];
            return;
        }
    }
}

/* ---------- Helpers ---------- */
static void trim_newline(char *s) {
    size_t n = strlen(s);
    if (n && s[n-1] == '\n') s[n-1] = '\0';
}
static void build_prompt(char *out, size_t cap) {
    char cwd[PATH_MAX]; getcwd(cwd, sizeof(cwd));
    char host[256]; gethostname(host, sizeof(host));
    const char *user = getenv("USER"); if (!user) user = "user";
    snprintf(out, cap, "%s@%s:%s$mysh> ", user, host, cwd);
}
static int parse(char *line, char *argv[]) {
    int argc = 0;
    char *tok = strtok(line, " \t");
    while (tok && argc < MAX_ARGS-1) {
        argv[argc++] = tok;
        tok = strtok(NULL, " \t");
    }
    argv[argc] = NULL;
    return argc;
}

/* ---------- Built-ins ---------- */
static int bi_pwd(void) {
    char cwd[PATH_MAX];
    if (!getcwd(cwd, sizeof(cwd))) { perror("pwd"); return 1; }
    puts(cwd);
    return 0;
}
static int bi_cd(char *path) {
    if (!path) path = getenv("HOME");
    if (!path) { fprintf(stderr, "No such directory\n"); return 1; }
    if (chdir(path) == -1) {
        if (errno == ENOENT) fprintf(stderr, "No such directory\n");
        else fprintf(stderr, "Change directory failed\n");
        return 1;
    }
    return 0;
}
static bool is_builtin(const char *cmd) {
    return cmd && (
        !strcmp(cmd,"cd") ||
        !strcmp(cmd,"pwd") ||
        !strcmp(cmd,"exit") ||
        !strcmp(cmd,"export") ||
        !strcmp(cmd,"alias") ||
        !strcmp(cmd,"unalias") ||
        !strcmp(cmd,"which")
    );
}
static int run_builtin(char *argv[]) {
    if (!strcmp(argv[0], "pwd"))  return bi_pwd();
    if (!strcmp(argv[0], "cd"))   return bi_cd(argv[1]);
    if (!strcmp(argv[0], "exit")) exit(0);

    if (!strcmp(argv[0], "export")) {
        if (!argv[1]) { fprintf(stderr, "usage: export VAR=value\n"); return 1; }
        char *eq = strchr(argv[1], '=');
        if (!eq) { fprintf(stderr, "usage: export VAR=value\n"); return 1; }
        *eq = '\0';
        if (setenv(argv[1], eq+1, 1) != 0) { perror("export"); return 1; }
        return 0;
    }

    if (!strcmp(argv[0], "alias")) {
        if (!argv[1]) {
            for (int i = 0; i < ALIAS_N; i++)
                printf("alias %s='%s'\n", ALIASES[i].name, ALIASES[i].value);
            return 0;
        }
        char *eq = strchr(argv[1], '=');
        if (!eq) { fprintf(stderr, "usage: alias name='value'\n"); return 1; }
        *eq = '\0';
        char *name = argv[1];
        char *val  = eq + 1;
        size_t n = strlen(val);
        if (n >= 2 && ((val[0]=='\'' && val[n-1]=='\'') || (val[0]=='"' && val[n-1]=='"'))) {
            val[n-1] = '\0';
            val++;
        }
        alias_set(name, val);
        return 0;
    }

    if (!strcmp(argv[0], "unalias")) {
        if (!argv[1]) { fprintf(stderr, "usage: unalias name\n"); return 1; }
        alias_unset(argv[1]);
        return 0;
    }

    if (!strcmp(argv[0], "which")) {
        if (!argv[1]) { fprintf(stderr, "usage: which cmd\n"); return 1; }
        const char* a = alias_lookup(argv[1]);
        if (a) { printf("%s: aliased to %s\n", argv[1], a); return 0; }
        const char *path = getenv("PATH"); if (!path) path = "/bin:/usr/bin";
        char buf[PATH_MAX];
        const char *p = path;
        while (*p) {
            const char *colon = strchr(p, ':');
            size_t len = colon ? (size_t)(colon - p) : strlen(p);
            if (len >= sizeof(buf)) len = sizeof(buf)-1;
            strncpy(buf, p, len); buf[len] = '\0';
            if (len && buf[len-1] != '/') strncat(buf, "/", sizeof(buf)-strlen(buf)-1);
            strncat(buf, argv[1], sizeof(buf)-strlen(buf)-1);
            if (access(buf, X_OK) == 0) { puts(buf); return 0; }
            if (!colon) break;
            p = colon + 1;
        }
        return 1;
    }

    return 1;
}

/* ---------- External ---------- */
static int run_external(char *argv[]) {
    pid_t pid = fork();
    if (pid < 0) { fprintf(stderr, "Failed to create process\n"); return 1; }
    if (pid == 0) {
        execvp(argv[0], argv);
        fprintf(stderr, "Failed to execute command\n");
        _exit(127);
    }
    int status=0; waitpid(pid, &status, 0);
    return WIFEXITED(status)? WEXITSTATUS(status) : 1;
}

/* ---------- ~/.myshrc ---------- */
static void source_rc(void) {
    const char *home = getenv("HOME");
    if (!home) return;
    char path[PATH_MAX]; snprintf(path, sizeof(path), "%s/.myshrc", home);
    FILE *f = fopen(path, "r");
    if (!f) return;

    char buf[MAX_LINE];
    while (fgets(buf, sizeof(buf), f)) {
        if (buf[0] == '#' || buf[0] == '\n') continue;
        buf[strcspn(buf, "\n")] = 0;
        if (!*buf) continue;

        char tmp[MAX_LINE]; strncpy(tmp, buf, sizeof(tmp)); tmp[sizeof(tmp)-1] = '\0';
        char *argv[MAX_ARGS];
        int argc = parse(tmp, argv);
        if (argc == 0) continue;

        if (is_builtin(argv[0])) run_builtin(argv);
        else run_external(argv);
    }
    fclose(f);
}

/* ---------- Main ---------- */
int main(void) {
    char line[MAX_LINE];
    char prompt[PATH_MAX + 64];

    /* source ~/.myshrc once at startup */
    source_rc();

    while (1) {
        build_prompt(prompt, sizeof(prompt));

        /* Readline: history + editing */
        char *lineptr = readline(prompt);
        if (!lineptr) { puts(""); break; }     /* Ctrl-D */
        if (*lineptr) add_history(lineptr);

        /* copy to fixed buffer for parse */
        strncpy(line, lineptr, sizeof(line));
        line[sizeof(line)-1] = '\0';
        free(lineptr);

        trim_newline(line);
        if (!*line) continue;

        char *argv[MAX_ARGS];
        char tmp[MAX_LINE]; strncpy(tmp, line, sizeof(tmp)); tmp[sizeof(tmp)-1]='\0';
        int argc = parse(tmp, argv);
        if (argc == 0) continue;

        /* alias expansion on first token (simple) */
        const char* a = alias_lookup(argv[0]);
        if (a) {
            char expanded[MAX_LINE];
            char first[MAX_LINE]; strncpy(first, line, sizeof(first)); first[sizeof(first)-1] = '\0';
            char *sp = strchr(first, ' ');
            const char *rest = sp ? (line + (sp - first)) : "";
            snprintf(expanded, sizeof(expanded), "%s%s", a, rest);
            strncpy(tmp, expanded, sizeof(tmp)); tmp[sizeof(tmp)-1] = '\0';
            parse(tmp, argv);
        }

        int rc = is_builtin(argv[0]) ? run_builtin(argv) : run_external(argv);
        (void)rc;
    }
    return 0;
}
